# Javascript 设计模式

## 设计模式的分类

1. 创建模式
    
    提供对象创建机制，增加现有代码的灵活性和重用。

    包活：单利模式、工厂方法、抽象工厂、建造者模式、原型模式

2. 结构型模式

    解释如何将对象和类组装成更大的结构，同时保持结构的灵活性和高效性。

    包括：代理模式、组合模式、亨元模式、 装饰模式、 适配器模式、桥接模式、外观模式、

3. 行为型模式

    负责有效的沟通和对象之间的责任分配。

    包括：策略模式、观察者模式、命令模式、模板方法、职责连模式、中介者模式、状态模式、迭代器模式、访问者模式、备忘录模式、解释器模式

    

## 设计模式的七大原则
1. 单一职责原则

    含义：一个类只负责一个功能领域中的相应职责。

    栗子：就像一家公司，团队中每个人都分工明确。有产品经理，项目经理，技术经理，QA经理等等。

    好处：降低类复杂性降低，提高代码可读性，提高可维护性。


2. 开闭原则

    含义：软件模块应该对扩展开放，对修改关闭。在程序需要进行新增功能的时候，不能去修改原有的代码，而是新增代码。

    栗子：就像插座一样，可以给很多不同的电器充电，但是不需要改变插座本身，只要提前把插头的规格定义好。

    好处：为了使程序的扩展性好，易于维护和升级。

3. 里氏代换原则

    含义：子类可以扩展父类的功能，但不能改变父类原有的功能

    栗子：正好今天请我去吃小龙虾，那就说说虾，它是一种食品。虾的衍生类很多有南极红虾、青虾、河虾、草虾、对虾、明虾、龙虾等，如果衍生类替换了基类的原本方法，如把食品改成了体育用品（那么软件的基本功能受到影响），就不符合里氏代换原则。

    好处：对实现抽象化的具体步骤的规范。

4. 依赖倒转原则

    含义：高层模块不应该依赖低层模块，二者都应该依赖其抽象。针对接口编程，而不是针对实现编程。

    栗子：以电脑为例,无论主板、CPU、内存、硬件都是在针对接口设计的，如果出现某个局部的配件坏了就只要替换对应的配件就行了。如果针对实现来设计，那么电脑显示屏坏了就需要把主机也一并换掉。

    好处：降低模块间的耦合。

5. 接口隔离原则

    含义：使用多个隔离的接口，比使用单个接口要好，将臃肿庞大的接口拆分成更小的接口。

    栗子：假设要设计操控机器人的接口，不能只有行动和停止的接口，行动可以拆分成前进，后退，转向，跳跃，等等，接口拆分可以使组合更多。

    好处：提高系统的灵活性和可维护性。

6. 合成复用原则

    含义：就是能用合成/聚合的地方，绝不用继承。尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。

    栗子：汽车按“动力源”划分可分为汽油汽车、电动汽车等；按“颜色”划分可分为白色汽车、黑色汽车和红色汽车等。如果同时考虑这两种分类，其组合就很多。

    好处：提高灵活性，降低类与类之间的耦合度。

7. 迪米特法则 

    含义：又叫最少知道原则，一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。

    栗子：智能音箱，只需要把指令告诉智能音箱，智能音箱就会识别指令去调用各种已链接的电器，如：我要看湖南卫视，把空调温度低一点，扫地机器人开启清扫，等等。智能音箱帮我们解决了要找很多遥控器的烦恼。

    好处：降低类之间的耦合，减少对其他类的依赖。
   


## 多态

1. 多态的实际含义是：同一操作作用于不同的对象上面，可以产生不同的解释和不同的执行结 果

2. 多态背后的思想是将“做什么”和“谁去做以及怎样去做”分离开来，也就是将“不变的事 物”与 “可能改变的事物”分离开来

## 封装

1. 封装的目的是将信息隐藏

2. 找到变化并封装之

---

## JavaScript

1. 原型模式和基于原型继承的 JavaScript 对象系统

2. 事实上，JavaScript 中的根对象是 Object.prototype 对象。Object.prototype 对象是一个空的 对象。我们在 JavaScript 遇到的每个对象，实际上都是从 Object.prototype 对象克隆而来的， Object.prototype 对象就是它们的原型

3. ECAMScript 3 给 Function 的原型定义了两个方法，它们是 Function.prototype.call 和 Function. prototype.apply

## 闭包

1. 闭包的形成与 变量的作用域以及变量的生存周期密切相关

### 闭包作用

1. 分装变量

2. 延续局部变量的寿命

## 作用域

> **变量的作用域，就是指变量的有效范围**

1.  如果变量前面没有带上关键字 var，这个变量就会成为 全局变量

2.  var 关键字在函数中声明变量，这时候的变量即是局部变量，只有在该函 数内部才能访问到这个变量，在函数外面是访问不到的

3.  在 JavaScript 中，函数可以用来创造函数作用域。此时的函数像一层半透明的玻璃，在函数 里面可以看到外面的变量，而在函数外面则无法看到函数里面的变量。这是因为当在函数中搜索 一个变量的时候，如果该函数内并没有声明这个变量，那么此次搜索的过程会随着代码执行环境 创建的作用域链往外层逐层搜索，一直搜索到全局对象为止。变量的搜索是从内到外而非从外到 内的

    下面这段包含了嵌套函数的代码，也许能帮助我们加深对变量搜索过程的理解

```
var a = 1;

var func1 = function(){
    var b = 2;
    var func2 = function(){
        ar c = 3;
        alert ( b );     // 输出：2
        alert ( a );     // 输出：1
    }
    func2();
    alert ( c );    // 输出：Uncaught ReferenceError: c is not defined
};

func1()
```

4. 而对于在函数内用 var 关键字声明的局部变量来说，当退出函数时，这些局部变量即失去了 它们的价值，它们都会随着函数调用的结束而被销毁

## 高阶函数

> **高阶函数是指至少满足下列条件之一的函数**

1. 函数可以作为参数被传递

```
把函数当作参数传递，这代表我们可以抽离出一部分容易变化的业务逻辑，把这部分业务逻 辑放在函数参数中，这样一来可以分离业务代码中变化与不变的部分。其中一个重要应用场景就 是常见的回调函数
```

2. 函数可以作为返回值输出

```
相比把函数当作参数传递，函数当作返回值输出的应用场景也许更多，也更能体现函数式编 程的巧妙。让函数继续返回一个可执行的函数，意味着运算过程是可延续的。
```

