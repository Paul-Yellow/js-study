# 函数扩展

## 函数参数默认值

1. 函数参数默认值和ES5不在一样，可以直接在参数中进行默认赋值

2. 不能在函数体中对函数参数进行let和const 声明会报错但是可以进行var 声明

3. 函数参数不能有同名的参数变量

4. 函数参数默认值可以事表达式、函数等任意数据类型

5. 可以与结构赋值默认值配合使用，并且设置默认值得参数应依次放在尾参数

6. 函数也有length属性   函数的length就是参数的个数，但是如果设置了参数默认值函数的length属性就不准确了，只会记录到设置默认值之前的参数。

7. 函数参数设置了参数默认值 ，函数在初始化的时候会形成一个单独的 **参数作用域**，这种行为只会在设置参数默认值得时候会出现

## rest 参数
ES6中引入了rest参数 *（...变量名）*，由于获取多余的参数，可以代替arguments。arguments它是一个类数组，有时候需要转为数组我们才可以使用数组上的方法，但是rest参数就直接是数组了。


## 箭头函数

箭头函数中没有自己的this，导致内部的this总是指向外层代码块的this，所以也不能改变this的指向，以及不能用作构造函数。也就是我们常说的箭头函数中的this绑定的是定义的时候的作用域，而不是运行时候的作用域。

**注意：** 箭头函数中没有this对象。

## 双冒号运算符 

ES5中我们可以通过call、apply、bind 来实现改变this的指向，在ES6新的提案中我们可以用 （ :: ）来进行函数的绑定，双冒号的左边是一个对象 右面是一个函数，该运算符会自动的将左边的对象作为上下文环境绑定到右边的函数上。

## 函数的尾调用
尾调用（tail call）是函数编程中的一个重要的概念 。定义：函数的最后一步调用另外一个函数。
函数的每次调用都会形成一个“调用记录”，就是我们常说的“调用帧”。假设在A函数内部有个函数B，当调用函数的时候就会A调用帧的上方多出一个B的调用帧，依次类推如果B函数中仍有别的函数，就会形成一个“调用栈”（call stack）。

尾调用由于是函数的最后一步 不用保留外层函数的调用帧。从而进行内存优化

**用途：** 递归是非常消耗内存的，很容易造成 “栈溢出” （stack overflow）,如果采用尾部调用就可以很好的解决这个问题了。

## 尾递归的实现
尾递归的实现，需要改写递归函数。简言之，就是把递归函数体中内部的变量，想办法改写写到参数中。